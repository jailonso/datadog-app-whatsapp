{"version":3,"file":"framepost.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAmB,UAAID,IAEvBD,EAAgB,UAAIC,IARtB,CASGK,MAAM,WACT,O,wlBCVA,YACA,SAQA,cAGI,WAAYC,QAAA,IAAAA,IAAAA,EAAA,IAAZ,MACI,YAAMA,IAAQ,K,OAEd,EAAKC,QAAUD,EAAQC,SAAW,KAElC,EAAKC,aAAe,EAAKA,aAAaC,KAAK,GAE3CC,OAAOC,iBAAiB,UAAW,EAAKH,cAEpC,EAAKI,SACL,EAAKC,UAAU,EAAAC,yBAAyB,WACpC,SAAKC,SAASC,eAItB,EAAKC,e,EAwBb,OA1C0C,OAqB5B,YAAAC,UAAV,WACI,OAAO,IAAAA,WAAU,eAAgBC,KAAKC,QAGhC,YAAAC,cAAV,SAAwBC,GACpBZ,OAAOa,oBAAoB,UAAWJ,KAAKX,cAE3CW,KAAKK,YAAcF,EAAGG,MAAM,GAE5B,IAAMC,EAAUP,KAAKQ,eAAeR,KAAKZ,SAEzCY,KAAKK,YAAYI,YAAYF,GAE7BP,KAAKJ,SAASc,SAAS,EAAAC,iBAAiBC,aAAcL,IAG1D,YAAAM,QAAA,WACI,YAAMA,QAAO,WAEbtB,OAAOa,oBAAoB,UAAWJ,KAAKX,eAEnD,EA1CA,CAPA,OAO0CyB,cAA7B,EAAAC,YAAAA,G,iBCab,IAAYC,EALAC,EALAN,EAZAO,E,6MAAAA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KACnB,4BACA,gBACA,oBACA,sBACA,mCAGQ,EAAAC,oBAAA,EAAAA,kBAAiB,KACzB,mBAGQR,EAAA,EAAAA,mBAAA,EAAAA,iBAAgB,KACxB,4BACA,qCAGQM,EAAA,EAAAA,uBAAA,EAAAA,qBAAoB,KAC5B,QACA,eAGQD,EAAA,EAAAA,oBAAA,EAAAA,kBAAiB,KACzB,YACA,gBAGS,EAAAI,wBAA0B,IAE1B,EAAAzB,wBAA0B,yB,8mBCzBvC,kBACI,mBACI,YAAM,wBAAsB,K,OAO5B0B,OAAOC,eAAe,EAAMC,EAAsBC,WAElD,EAAKC,KAAO,wB,EAEpB,OAb2C,OAa3C,EAbA,CAA2CC,OAA9B,EAAAH,sBAAAA,EAeb,kBACI,mBACI,YAAM,sBAAoB,K,OAE1BF,OAAOC,eAAe,EAAMK,EAAoBH,WAEhD,EAAKC,KAAO,sB,EAEpB,OARyC,OAQzC,EARA,CAAyCC,OAA5B,EAAAC,oBAAAA,EAUb,kBACI,mBACI,YAAM,qBAAmB,K,OAEzBN,OAAOC,eAAe,EAAMM,EAAqBJ,WAEjD,EAAKC,KAAO,uB,EAEpB,OAR0C,OAQ1C,EARA,CAA0CC,OAA7B,EAAAE,qBAAAA,G,kbC7Bb,aAAS,6EAAAb,eACT,aAAS,8EAAAc,gBAET,YACA,a,sFCEa,EAAA9B,UAAY,SAAC+B,EAAgB7B,GACtC,OAAIA,EACO,CACH8B,IAAA,SAAIxB,GACA,OAAOyB,QAAQD,IAAI,UAAGD,EAAM,aAAKvB,KAErC0B,MAAA,SAAM1B,GACF,OAAOyB,QAAQC,MAAM,UAAGH,EAAM,aAAKvB,MAIpC,CACHwB,IAAG,aACHE,MAAK,gB,q7DCnBjB,YACA,SACA,SAEA,SAIA,cAGI,WAAY9C,G,YAAA,IAAAA,IAAAA,EAAA,IACR,YAAMA,IAAQ,KAiEtB,OArE2C,OAWvC,YAAA+C,eAAA,SAAkBC,EAA0B/C,GACpC+C,EAAMC,eACNpC,KAAKqC,oBACDF,EAAMC,cACND,EAAMG,IACNlD,IASZ,YAAAmD,wBAAA,SAA2BC,EAAsBC,EAAarD,GACtDoD,EAAaE,QACb1C,KAAKqC,oBAAuBG,EAAcC,EAAKrD,IAI/C,YAAAiD,oBAAR,SACIG,EACAC,EACArD,GAEAY,KAAKyC,IAAM,IAAIE,IAAIF,GAEnB,IAAMG,EAAiB,IAAIC,eAE3B7C,KAAKK,YAAcuC,EAAeE,MAElC,IAAMvC,EAAUP,KAAKQ,eAAepB,GAEpCY,KAAKK,YAAY0C,UAAY/C,KAAKX,aAAaC,KAAKU,MAEpDA,KAAKF,eAEL0C,EAAa/B,YAAYF,EAASP,KAAKyC,IAAIO,OAAQ,CAC/CJ,EAAeK,QAGnBjD,KAAKJ,SAASc,SAAS,EAAAC,iBAAiBC,aAAcL,IAGpD,YAAA2C,kBAAN,W,kGACwB,SAAMlD,KAAKmD,QAC3B,EAAAxD,0B,OAIJ,OALMyD,EAAc,SAGdC,EAASrD,KAAKJ,SAASC,YAEtB,CAAP,GAAO,IAAAyD,iBAAgBD,EAAQD,YAGzB,YAAAlD,cAAV,aAEU,YAAAH,UAAV,WACI,OAAO,IAAAA,WAAU,gBAAiBC,KAAKC,QAE/C,EArEA,CAA2C,EAAAa,cAA9B,EAAAe,aAAAA,G,wFCAA,EAAA0B,YAAc,SAAC9D,GACxB,IAAM4D,EAAgC,GAEtC,MAAO,CACH3C,SAAA,SAAS8C,EAAwBjD,GACzBd,GACA4D,EAAOI,KAAK,CACRD,KAAI,EACJjD,QAAO,EACPmD,KAAM,IAAIC,QAItB9D,UAAS,WACL,OAAOwD,M,09CCtBnB,YAMA,SAMA,SASA,SASA,aAwBI,WAAY,GAAZ,WAAY,aAKa,GAAE,EAJvB,IAAApD,MAAAA,OAAK,IAAG,GAAK,EACb,IAAAR,QAAAA,OAAO,IAAG,GAAK,EACfmE,EAAgB,mBAChB,IAAAC,eAAAA,OAAc,IAAG,IAAAzC,wBAAuB,EAExCpB,KAAKC,MAAQA,EACbD,KAAKP,QAAUA,EACfO,KAAK4D,sBACoBE,IAArBF,EAAiCA,EAAmBC,EACxD7D,KAAK6D,eAAiBA,EACtB7D,KAAK+D,SAAU,IAAAC,SACfhE,KAAKiE,mBAAqB,GAC1BjE,KAAKkE,sBAAwB,GAC7BlE,KAAKmE,qBAAuB,GAC5BnE,KAAKoE,yBAA2B,GAChCpE,KAAKqE,WAAY,EAEjBrE,KAAKsE,OAAStE,KAAKD,YACnBC,KAAKJ,UAAW,IAAA2D,aAAY9D,GAE5BO,KAAKuE,aACAC,MAAK,WACF,EAAKF,OAAOvC,IAAI,kDAEnB0C,OAAM,SAACC,GACJ,EAAKJ,OAAOvC,IAAI2C,MAiYhC,OArXU,YAAAC,KAAN,SACIC,EACAC,G,0FAGI,O,sBAAA,GAAM7E,KAAK8E,a,cAAX,S,aAEA,O,SAAO,CAAP,EAAO,M,OAGX,MAAO,CAAP,EAAO9E,KAAKS,YAAY,EAAAS,YAAY6D,MAAOH,EAAWC,YAM1D,YAAAG,GAAA,SAAYJ,EAAmBK,GAA/B,WACSjF,KAAKiE,mBAAmBW,KACzB5E,KAAKiE,mBAAmBW,GAAa,IAGzC,IAAMM,GAAK,IAAAC,kBAAiB,GAM5B,OAJAnF,KAAKiE,mBAAmBW,GAAWM,GAAMD,EAEzCjF,KAAKsE,OAAOvC,IAAI,wCAAiC6C,EAAS,MAEnD,WACH,EAAKX,mBAAmBW,IAAa,IAAAQ,MACjC,EAAKnB,mBAAmBW,GACxBM,GAGJ,EAAKZ,OAAOvC,IAAI,yCAAkC6C,MAQpD,YAAAzB,QAAN,SACIkC,EACAR,EACA1F,G,YAAA,IAAAA,IAAAA,EAAA,I,sGAEoB,SAAMa,KAAKS,YAC3B,EAAAS,YAAYoE,QACZD,EACAR,I,OAoBJ,OAvBMU,EAAc,SAOdC,EAAYD,EAAYL,GAExBO,EAA6B,WAC/B,EAAKvB,uBAAwB,IAAAkB,MACzB,EAAKlB,sBACLsB,IAIFE,EAAiB,WACnB,EAAKtB,0BAA2B,IAAAgB,MAC5B,EAAKlB,sBACLsB,IAID,CAAP,EAAO,IAAIG,SAAQ,SAACC,EAASC,GACzB,IAAIC,EA2BJ,EAAK5B,sBAAsBsB,GAzBc,SACrCO,EACAxF,GAEAyF,aAAaF,GAEbL,IACAC,IAEInF,EAAQiD,OAAS,EAAAtC,YAAY+E,eAC7BJ,EAAOE,GAEPH,EAAQG,IAchB,EAAK3B,yBAAyBoB,GANL,WACrBQ,aAAaF,GACbD,EAAO,IAAI,EAAAjE,uBAMfkE,EAAQI,YAAW,WACfT,IACAC,IACAG,EAAO,IAAI,EAAAlE,uBACZxC,EAAQgH,SAAW,EAAKtC,4BAUnC,YAAAnE,UAAA,SACI2F,EACAe,GAFJ,WAkCI,OAFApG,KAAKmE,qBAAqBkB,GA5BE,SACxBgB,EACAC,GAA0B,qC,0DAGtB,O,sBAAA,GAAMtG,KAAK8E,a,OAEM,OAFjB,SAEiB,GAAMsB,EACnBC,EACAC,I,cAFEP,EAAW,SAKjB/F,KAAKS,YACD,EAAAS,YAAYqF,SACZlB,EACAU,EACAO,EAAepB,I,+BAGnBlF,KAAKS,YACD,EAAAS,YAAY+E,eACZZ,EACA,EACAiB,EAAepB,I,+BAOpB,WACH,EAAKf,sBAAuB,IAAAiB,MACxB,EAAKjB,qBACLkB,KASN,YAAAmB,WAAN,W,0FACI,GAAIxG,KAAKqE,UACL,MAAO,CAAP,EAAO,M,iBAIa,O,sBAAA,GAAMrE,KAAKuE,c,OAC/B,MAAO,CAAP,EADoB,SAAuB,S,OAG3C,O,SAAO,CAAP,EAAO,M,yBAOT,YAAAO,UAAN,W,0FACwB,SAAM9E,KAAKuE,c,OAC/B,MAAO,CAAP,EADoB,SAAuB,iBAQ/B,YAAAA,WAAhB,W,0FACI,SAAMvE,KAAK+D,QAAQ0C,S,OAEnB,GAFA,SAEIzG,KAAKqE,UACL,MAAM,IAAI,EAAAzC,qBAGd,MAAO,CAAP,EAAO5B,KAAK+D,QAAQ0C,iBAGR,YAAAC,gBAAhB,SAAgCvG,G,kGAExB,O,sBAAA,GAAMH,KAAKuE,c,OAMX,GANA,SAEMoC,EAAiB3G,KAAK2G,eAAexG,GAErCI,GAAU,IAAAqG,aAAYzG,EAAG0E,MAE3B8B,EAAgB,CAChB,OAAQpG,EAAQiD,MACZ,KAAK,EAAAtC,YAAY6D,MACb/E,KAAK6G,YAAYtG,GACjB,MAEJ,KAAK,EAAAW,YAAYoE,QACbtF,KAAK8G,cAAcvG,GACnB,MAEJ,KAAK,EAAAW,YAAY+E,eACjB,KAAK,EAAA/E,YAAYqF,SACbvG,KAAK+G,eAAexG,GAK5BP,KAAKJ,SAASc,SACV,EAAAC,iBAAiBqG,gBACjBzG,QAGJP,KAAKsE,OAAOrC,MAAM,qC,kEAOpB,YAAA4E,YAAV,SAA+BtG,GAC3B,IAAM0G,EAAgBjH,KAAKiE,mBAAmB1D,EAAQ2G,KAElDD,GACA5F,OAAO8F,OAAOF,GAAeG,SAAQ,SAAAnC,GACjC,OAAAA,EAAQ1E,EAAQsE,KAAMtE,OAKxB,YAAAuG,cAAV,SAAiCvG,GAC7B,IAAM0E,EAAUjF,KAAKmE,qBAAqB5D,EAAQ2G,KAE9CjC,IACAA,EAAQ1E,EAAQsE,KAAMtE,GAEtBP,KAAKsE,OAAOvC,IAAI,+BAAwBxB,EAAQ2G,QAI9C,YAAAH,eAAV,SAAkCxG,GAC9B,IAAMiF,EAAYjF,EAAQiF,UAEpBP,EAAUO,GAAaxF,KAAKkE,sBAAsBsB,GAEpDP,GACAA,EAAQ1E,EAAQsE,KAAMtE,IAId,YAAAE,YAAhB,SACI+C,EACA0D,EACArC,EACAW,G,kGAEiB,SAAMxF,KAAKuE,c,OAE5B,GAFQ8C,EAAS,SAAuB,KAEpCrH,KAAKqE,UACL,MAAM,IAAI,EAAAzC,qBAgBd,OAbMrB,GAAmB,IAAA+G,WAAU,CAC/B9D,KAAI,EACJ+D,WAAY,EAAApG,kBAAkBqG,GAC9BN,IAAG,EACHrC,KAAI,EACJK,IAAI,IAAAC,oBACJK,UAAS,IAGb6B,EAAK5G,YAAYF,GAEjBP,KAAKJ,SAASc,SAAS,EAAAC,iBAAiBC,aAAcL,GAE/C,CAAP,EAAOA,WAGD,YAAAT,aAAV,sBACIE,KAAKyH,UAAYvB,YAAW,WACxB,EAAKnC,QAAQ8B,OAAO,IAAI,EAAAtE,uBACxB,EAAKV,YACNb,KAAK4D,mBAGF,YAAAvE,aAAV,SAAuBc,GACfH,KAAK0H,cAAcvH,IACnBH,KAAKJ,SAASc,SAAS,EAAAC,iBAAiBqG,gBAAiB7G,EAAG0E,MAExD7E,KAAKyH,WACLzB,aAAahG,KAAKyH,WAGtBzH,KAAKE,cAAcC,GAEfH,KAAKK,cACLL,KAAKK,YAAY0C,UAAY/C,KAAK0G,gBAAgBpH,KAAKU,OAG3DA,KAAK2H,eAAexH,IAEpBH,KAAKsE,OAAOrC,MAAM,sCAIhB,YAAA0E,eAAV,SAAyBxG,GACrB,IAAMI,EAAUJ,EAAG0E,KAEnB,OACItE,EAAQiD,MACRjD,EAAQ2E,IACR3E,EAAQgH,aAAe,EAAApG,kBAAkBqG,IAIvC,YAAAE,cAAV,SAAwBvH,GACpB,OACIH,KAAK2G,eAAexG,IAAOA,EAAG0E,KAAKrB,OAAS,EAAAtC,YAAY0G,cAItD,YAAAD,eAAV,SAAyBxH,GACrB,GAAIH,KAAKK,YAAa,CAClB,IAAM0D,EAAsB,CACxBsD,KAAMrH,KAAKK,YACX2C,OAAQ7C,EAAG6C,OACX5D,QAASe,EAAG0E,KAAKA,MAGrB7E,KAAK+D,QAAQ6B,QAAQ7B,KAInB,YAAAvD,eAAV,SAAkCpB,GAS9B,OAR4B,IAAAkI,WAAU,CAClC9D,KAAM,EAAAtC,YAAY0G,aAClBL,WAAY,EAAApG,kBAAkBqG,GAC9BN,IAAK,GACLrC,KAAMzF,EACN8F,IAAI,IAAAC,uBAMZ,YAAAtE,QAAA,WACIb,KAAKqE,WAAY,EACjBrE,KAAK+D,QAAQ8B,OAAO,IAAI,EAAAjE,sBAEpB5B,KAAKK,aACLL,KAAKK,YAAYwH,QAGjB7H,KAAKyH,WACLzB,aAAahG,KAAKyH,WAGtBpG,OAAO8F,OAAOnH,KAAKoE,0BAA0BgD,SAAQ,SAAAvG,GACjD,OAAAA,QAGZ,EAnbA,GAAsB,EAAAC,aAAAA,G,kgCC9BtB,YAMA,SASa,EAAAkD,MAAQ,WACjB,IAAI4B,EAA0B,aAC1BC,EAA4B,aAC1BY,EAAU,IAAId,SAAW,SAACmC,EAAKC,GACjCnC,EAAUkC,EACVjC,EAASkC,KAGb,MAAO,CACHnC,QAAO,EACPC,OAAM,EACNY,QAAO,IAKF,EAAAtB,iBAAmB,SAAC6C,GAC7B,YAD6B,IAAAA,IAAAA,EAAA,IAC7B,KAAIC,MAAMD,IAAI,GAAEE,KAAI,WAAM,UAAoB,GAAhBC,KAAKC,WAAgBC,SAAS,OAAKC,KAAK,KAG7D,EAAAlD,KAAO,SAACmD,EAAarB,GAC9B,IAA8B,EAAAqB,EAAtB,EAACrB,EAET,OAFgB,KAAS,IAAnB,8BAkBG,EAAA5D,gBAAkB,SAC3BkF,EACApF,GAEA,IAfAqF,EAEMC,EAcAC,EADYH,EAAaI,OAAOxF,GACNyF,QAC5B,SAAAC,GAAQ,OAAAA,EAAKtF,OAAS,EAAA7C,iBAAiBqG,mBAErC+B,GAnBNN,EAqBI,SAAAK,GAAQ,OAAAA,EAAKvI,QAAQ2E,IAnBnBwD,EAA4B,GAkB9BC,EAhBEvB,SAAQ,SAAA0B,GACVJ,EAAID,EAAMK,IAASA,KAGhBJ,GAgBDM,EAAiC,GAEjCC,EAAqB,SAAC,G,IACxBvF,EAAI,OACJnD,EAAO,UAED2I,EAA8B,CAChChE,GAAI3E,EAAQ2E,GACZiE,UAAW,EAAAlI,qBAAqBmI,KAChCC,SAAU3F,EACVnD,QAAO,GAGL+I,EAAeP,EAAyBxI,EAAQ2E,IAQtD,OANIoE,IACAJ,EAAYK,YAAcD,EAAa5F,KACvCwF,EAAYM,UACPF,EAAa5F,KAAK+F,UAAY/F,EAAK+F,WAAa,KAGlDP,GAqBX,OAlBAV,EACKK,QAAO,SAAAC,GAAQ,OAAAA,EAAKtF,OAAS,EAAA7C,iBAAiBC,gBAC9CwG,SAAQ,SAAAjH,GACL,IAAM+I,EAAcD,EAAmB9I,GAEvC6I,EAAavF,KAAKyF,MAG1B9F,EACKyF,QAAO,SAAAC,GAAQ,OAAAA,EAAKtF,OAAS,EAAA7C,iBAAiBC,gBAC9CwG,SAAQ,SAAAjH,GACL,IAAM+I,EAAcD,EAAmB9I,GAEvC+I,EAAYC,UAAY,EAAAlI,qBAAqByI,GAE7CV,EAAavF,KAAKyF,MAGnBF,EACFH,QAAO,SAAAC,GAAQ,OAAAA,EAAKvI,QAAQ2G,MAAQ,EAAAvH,2BACpCgK,MAAK,SAACC,EAAGC,GAAM,OAAAD,EAAEP,SAASI,UAAYI,EAAER,SAASI,cAG1D,IAQMK,EAAmB,SAAC,G,IAAErI,EAAI,OAAElB,EAAO,UAAEwJ,EAAK,QAC5C,OAAQtI,GACJ,KAAK,EAAAF,sBAAsBE,KACvB,OAAO,IAAI,EAAAF,sBAEf,KAAK,EAAAI,oBAAoBF,KACrB,OAAO,IAAI,EAAAE,oBAEf,QACI,IAAMqI,EAAI,IAAItI,MAAMnB,GAGpB,OAFAyJ,EAAEvI,KAAOA,EACTuI,EAAED,MAAQA,EACHC,IAKN,EAAA1C,UAAY,SAAC/G,GACtB,IA1BoB0B,EA0BhB4C,EAAOtE,EAAQsE,KACfoF,EAAgB,EAAAjJ,kBAAkBkJ,KAOtC,OALIrF,aAAgBnD,QAChBuI,EAAgB,EAAAjJ,kBAAkBmJ,MAClCtF,EA9BG,CACHtE,SAFgB0B,EA+BM4C,GA7BPtE,QACfkB,KAAMQ,EAAMR,KACZsI,MAAO9H,EAAM8H,QA8BV,EAAP,KACOxJ,GAAO,CACV0J,cAAa,EACbpF,KAAI,KAIC,EAAA+B,YAAc,SAACrG,GACxB,OAAIA,EAAQ0J,gBAAkB,EAAAjJ,kBAAkBmJ,MACrC,EAAP,KACO5J,GAAO,CACVsE,KAAMiF,EAAiBvJ,EAAQsE,QAIhCtE,KClKP6J,EAA2B,G,OAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBxG,IAAjByG,EACH,OAAOA,EAAazL,QAGrB,IAAIC,EAASqL,EAAyBE,GAAY,CAGjDxL,QAAS,IAOV,OAHA0L,EAAoBF,GAAUG,KAAK1L,EAAOD,QAASC,EAAQA,EAAOD,QAASuL,GAGpEtL,EAAOD,QClBWuL,CAAoB,K","sources":["webpack://framepost/webpack/universalModuleDefinition","webpack://framepost/./src/child.ts","webpack://framepost/./src/constants.ts","webpack://framepost/./src/errors.ts","webpack://framepost/./src/index.ts","webpack://framepost/./src/logger.ts","webpack://framepost/./src/parent.ts","webpack://framepost/./src/profiler.ts","webpack://framepost/./src/shared.ts","webpack://framepost/./src/utils.ts","webpack://framepost/webpack/bootstrap","webpack://framepost/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"framepost\"] = factory();\n\telse\n\t\troot[\"framepost\"] = factory();\n})(self, function() {\nreturn ","import { ProfileEventType, REQUEST_KEY_GET_PROFILE } from './constants';\nimport { getLogger } from './logger';\nimport { SharedClient, SharedClientOptions } from './shared';\nimport type { Message } from './types';\n\nexport interface ChildClientOptions extends SharedClientOptions {\n    context?: any;\n}\n\nexport class ChildClient<C = any> extends SharedClient<C> {\n    context: any;\n\n    constructor(options: ChildClientOptions = {}) {\n        super(options);\n\n        this.context = options.context || null;\n\n        this.initListener = this.initListener.bind(this);\n\n        window.addEventListener('message', this.initListener);\n\n        if (this.profile) {\n            this.onRequest(REQUEST_KEY_GET_PROFILE, () =>\n                this.profiler.getEvents()\n            );\n        }\n\n        this.setInitTimer();\n    }\n\n    protected getLogger() {\n        return getLogger('child-client', this.debug);\n    }\n\n    protected onChannelInit(ev: MessageEvent<Message<C>>) {\n        window.removeEventListener('message', this.initListener);\n\n        this.messagePort = ev.ports[0];\n\n        const message = this.getInitMessage(this.context);\n\n        this.messagePort.postMessage(message);\n\n        this.profiler.logEvent(ProfileEventType.POST_MESSAGE, message);\n    }\n\n    destroy() {\n        super.destroy();\n\n        window.removeEventListener('message', this.initListener);\n    }\n}\n","export enum MessageType {\n    CHANNEL_INIT = 'channel_init',\n    EVENT = 'event',\n    REQUEST = 'request',\n    RESPONSE = 'response',\n    ERROR_RESPONSE = 'error_response'\n}\n\nexport enum MessageAPIVersion {\n    v1 = 'framepost/v1'\n}\n\nexport enum ProfileEventType {\n    POST_MESSAGE = 'post_message',\n    RECEIVE_MESSAGE = 'receive_message'\n}\n\nexport enum TransactionDirection {\n    UP = 'up',\n    DOWN = 'down'\n}\n\nexport enum SerializationType {\n    NONE = 'none',\n    ERROR = 'error'\n}\n\nexport const DEFAULT_REQUEST_TIMEOUT = 20000;\n\nexport const REQUEST_KEY_GET_PROFILE = 'framepost_get_profile';\n","/**\n * Typed errors allow consumer to distinguish failure cases\n */\n\nexport class HandshakeTimeoutError extends Error {\n    constructor() {\n        super('Handshake timed out');\n\n        /**\n         * Because we are targeting es5 in complilation, instanceOf checks won't work\n         * with the resulting error types. See https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/\n         * TODO: Can we upgrade the compilation target? What do we need to support in iframes?\n         */\n        Object.setPrototypeOf(this, HandshakeTimeoutError.prototype);\n\n        this.name = 'HandshakeTimeoutError';\n    }\n}\n\nexport class RequestTimeoutError extends Error {\n    constructor() {\n        super('Request timed out');\n\n        Object.setPrototypeOf(this, RequestTimeoutError.prototype);\n\n        this.name = 'RequestTimeoutError';\n    }\n}\n\nexport class ClientDestroyedError extends Error {\n    constructor() {\n        super('Client destroyed');\n\n        Object.setPrototypeOf(this, ClientDestroyedError.prototype);\n\n        this.name = 'ClientDestroyedError';\n    }\n}\n","export { ChildClient } from './child';\nexport { ParentClient } from './parent';\n\nexport * from './types';\nexport * from './errors';\n","/* eslint-disable no-console */\nexport interface Logger {\n    log(message: string): void;\n    error(message: string): void;\n}\n\nexport const getLogger = (prefix: string, debug: boolean): Logger => {\n    if (debug) {\n        return {\n            log(message: string) {\n                return console.log(`${prefix}: ${message}`);\n            },\n            error(message: string) {\n                return console.error(`${prefix}: ${message}`);\n            }\n        };\n    } else {\n        return {\n            log() {},\n            error() {}\n        };\n    }\n};\n","import { ProfileEventType, REQUEST_KEY_GET_PROFILE } from './constants';\nimport { getLogger } from './logger';\nimport { SharedClient, SharedClientOptions } from './shared';\nimport type { MessageProfileEvent, MessageProfile } from './types';\nimport { profileMessages } from './utils';\n\nexport interface ParentClientOptions extends SharedClientOptions {}\n\nexport class ParentClient<C = any> extends SharedClient<C> {\n    private url?: URL;\n\n    constructor(options: ParentClientOptions = {}) {\n        super(options);\n    }\n\n    /**\n     * Request a channel with a child client in an iframe. Must be called after child\n     * frame is fully loaded.\n     */\n    requestChannel<T>(frame: HTMLIFrameElement, context: T) {\n        if (frame.contentWindow) {\n            this.handleRequstChannel<T>(\n                frame.contentWindow,\n                frame.src,\n                context\n            );\n        }\n    }\n\n    /**\n     * Request a channel with the child client in a new tab or a new window opened with window.open().\n     * Must be called after the popup has fully loaded, if not blocked by a popup blocker.\n     */\n    requestChannelWithPopup<T>(targetWindow: Window, url: string, context: T) {\n        if (targetWindow.opener) {\n            this.handleRequstChannel<T>(targetWindow, url, context);\n        }\n    }\n\n    private handleRequstChannel<T>(\n        targetWindow: Window,\n        url: string,\n        context: T\n    ) {\n        this.url = new URL(url);\n\n        const messageChannel = new MessageChannel();\n\n        this.messagePort = messageChannel.port1;\n\n        const message = this.getInitMessage(context);\n\n        this.messagePort.onmessage = this.initListener.bind(this);\n\n        this.setInitTimer();\n\n        targetWindow.postMessage(message, this.url.origin, [\n            messageChannel.port2\n        ]);\n\n        this.profiler.logEvent(ProfileEventType.POST_MESSAGE, message);\n    }\n\n    async getMessageProfile(): Promise<MessageProfile[]> {\n        const childEvents = await this.request<any, MessageProfileEvent[]>(\n            REQUEST_KEY_GET_PROFILE\n        );\n        const events = this.profiler.getEvents();\n\n        return profileMessages(events, childEvents);\n    }\n\n    protected onChannelInit() {}\n\n    protected getLogger() {\n        return getLogger('parent-client', this.debug);\n    }\n}\n","import { ProfileEventType } from './constants';\nimport type { MessageProfileEvent, Message } from './types';\n\nexport interface Profiler {\n    logEvent(type: ProfileEventType, message: Message): void;\n    getEvents(): MessageProfileEvent[];\n}\n\nexport const getProfiler = (profile: boolean): Profiler => {\n    const events: MessageProfileEvent[] = [];\n\n    return {\n        logEvent(type: ProfileEventType, message: Message) {\n            if (profile) {\n                events.push({\n                    type,\n                    message,\n                    date: new Date()\n                });\n            }\n        },\n        getEvents() {\n            return events;\n        }\n    };\n};\n","import {\n    MessageType,\n    ProfileEventType,\n    DEFAULT_REQUEST_TIMEOUT,\n    MessageAPIVersion\n} from './constants';\nimport {\n    HandshakeTimeoutError,\n    RequestTimeoutError,\n    ClientDestroyedError\n} from './errors';\nimport { Logger } from './logger';\nimport { Profiler, getProfiler } from './profiler';\nimport type {\n    Deferred,\n    Message,\n    Channel,\n    EventHandler,\n    RequestHandler,\n    RequestOptions\n} from './types';\nimport { defer, randomInsecureId, omit, serialize, deserialize } from './utils';\n\nexport interface SharedClientOptions {\n    debug?: boolean;\n    profile?: boolean;\n    handshakeTimeout?: number;\n    requestTimeout?: number;\n}\n\nexport abstract class SharedClient<C> {\n    protected readonly debug: boolean;\n    protected readonly profile: boolean;\n    protected destroyed: boolean;\n    protected readonly handshakeTimeout: number;\n    protected readonly requestTimeout: number;\n    protected readonly channel: Deferred<Channel<C>>;\n    protected readonly logger: Logger;\n    protected readonly profiler: Profiler;\n    protected messagePort?: MessagePort;\n    protected initTimer?: ReturnType<typeof setTimeout>;\n    protected eventSubscriptions: {\n        [eventType: string]: { [id: string]: EventHandler };\n    };\n    protected responseSubscriptions: {\n        [id: string]: EventHandler;\n    };\n    protected requestSubscriptions: {\n        [requestKey: string]: RequestHandler;\n    };\n    protected onDestroyRequestHandlers: {\n        [id: string]: () => void;\n    };\n\n    constructor({\n        debug = false,\n        profile = false,\n        handshakeTimeout,\n        requestTimeout = DEFAULT_REQUEST_TIMEOUT\n    }: SharedClientOptions = {}) {\n        this.debug = debug;\n        this.profile = profile;\n        this.handshakeTimeout =\n            handshakeTimeout !== undefined ? handshakeTimeout : requestTimeout;\n        this.requestTimeout = requestTimeout;\n        this.channel = defer();\n        this.eventSubscriptions = {};\n        this.responseSubscriptions = {};\n        this.requestSubscriptions = {};\n        this.onDestroyRequestHandlers = {};\n        this.destroyed = false;\n\n        this.logger = this.getLogger();\n        this.profiler = getProfiler(profile);\n\n        this.getChannel()\n            .then(() => {\n                this.logger.log('Secure parent <-> child channel established');\n            })\n            .catch((reason: string) => {\n                this.logger.log(reason);\n            });\n    }\n\n    // each client must implement these methods since they will differ slightly\n    // in parent and child\n    protected abstract onChannelInit(event: MessageEvent<Message<C>>): void;\n    protected abstract getLogger(): Logger;\n\n    /**\n     * Sends an event to the opposite client\n     */\n    async send<T = any>(\n        eventType: string,\n        data: T\n    ): Promise<Message<T> | null> {\n        try {\n            await this.handshake();\n        } catch (e) {\n            return null;\n        }\n\n        return this.postMessage(MessageType.EVENT, eventType, data);\n    }\n\n    /**\n     * Subscribes an event handler for the given eventType. Returns an unsubscribe hook\n     */\n    on<T = any>(eventType: string, handler: EventHandler<T>): () => void {\n        if (!this.eventSubscriptions[eventType]) {\n            this.eventSubscriptions[eventType] = {};\n        }\n\n        const id = randomInsecureId(8);\n\n        this.eventSubscriptions[eventType][id] = handler;\n\n        this.logger.log(`Registered handler for event \"${eventType}\"`);\n\n        return () => {\n            this.eventSubscriptions[eventType] = omit(\n                this.eventSubscriptions[eventType],\n                id\n            );\n\n            this.logger.log(`Unsubscribed handler for event ${eventType}`);\n        };\n    }\n\n    /**\n     * Sends a request to the opposite client. There must be an accompanying request handler\n     * subscribed with `onRequest`. Resolves with the returned data or times out.\n     */\n    async request<Q = any, R = any>(\n        requestKey: string,\n        data?: Q,\n        options: RequestOptions = {}\n    ): Promise<R> {\n        const sentMessage = await this.postMessage(\n            MessageType.REQUEST,\n            requestKey,\n            data\n        );\n\n        // this is the random id of the specific request instance\n        const requestId = sentMessage.id;\n\n        const unsubscribeResponseHandler = () => {\n            this.responseSubscriptions = omit(\n                this.responseSubscriptions,\n                requestId\n            );\n        };\n\n        const clearOnDestroy = () => {\n            this.onDestroyRequestHandlers = omit(\n                this.responseSubscriptions,\n                requestId\n            );\n        };\n\n        return new Promise((resolve, reject) => {\n            let timer: ReturnType<typeof setTimeout>;\n\n            const responseHandler: EventHandler<R> = (\n                response: R,\n                message: Message<R>\n            ) => {\n                clearTimeout(timer);\n\n                unsubscribeResponseHandler();\n                clearOnDestroy();\n\n                if (message.type === MessageType.ERROR_RESPONSE) {\n                    reject(response);\n                } else {\n                    resolve(response);\n                }\n            };\n\n            /**\n             * A handler that will run if client.destroy() is called. This cancels the\n             * timeout for this requests, and rejects the promise\n             */\n            const onDestroyHandler = () => {\n                clearTimeout(timer);\n                reject(new ClientDestroyedError());\n            };\n\n            this.responseSubscriptions[requestId] = responseHandler;\n            this.onDestroyRequestHandlers[requestId] = onDestroyHandler;\n\n            timer = setTimeout(() => {\n                unsubscribeResponseHandler();\n                clearOnDestroy();\n                reject(new RequestTimeoutError());\n            }, options.timeout || this.requestTimeout);\n        });\n    }\n\n    /**\n     * Subscribes a request handler for the given request key. The return value\n     * from the subscribed handler is sent back to the opposite client. The handler may be async.\n     * Unlike event handlers, there may be only one request handler per request key. Returns\n     * an unsubscribe hook.\n     */\n    onRequest<Q = any, R = any>(\n        requestKey: string,\n        requestHandler: RequestHandler<Q, R>\n    ): () => void {\n        const requestEventHandler = async (\n            requestData: Q,\n            requestMessage: Message<Q>\n        ) => {\n            try {\n                await this.handshake();\n\n                const response = await requestHandler(\n                    requestData,\n                    requestMessage\n                );\n\n                this.postMessage(\n                    MessageType.RESPONSE,\n                    requestKey,\n                    response,\n                    requestMessage.id\n                );\n            } catch (e) {\n                this.postMessage(\n                    MessageType.ERROR_RESPONSE,\n                    requestKey,\n                    e,\n                    requestMessage.id\n                );\n            }\n        };\n\n        this.requestSubscriptions[requestKey] = requestEventHandler;\n\n        return () => {\n            this.requestSubscriptions = omit(\n                this.requestSubscriptions,\n                requestKey\n            );\n        };\n    }\n\n    /**\n     * Returns the context provided by the opposite client, or null\n     * if the handshake process fails\n     */\n    async getContext(): Promise<C | null> {\n        if (this.destroyed) {\n            return null;\n        }\n\n        try {\n            const { context } = await this.getChannel();\n            return context;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Rejects if the handshake process has failed or if the client was destroyed\n     */\n    async handshake(): Promise<C> {\n        const { context } = await this.getChannel();\n        return context;\n    }\n\n    /**\n     * A wrapper around the channel deferred object that also checks\n     * if the client has been destroyed before returning\n     */\n    protected async getChannel(): Promise<Channel<C>> {\n        await this.channel.promise;\n\n        if (this.destroyed) {\n            throw new ClientDestroyedError();\n        }\n\n        return this.channel.promise;\n    }\n\n    protected async messageListener(ev: MessageEvent<Message>) {\n        try {\n            await this.getChannel();\n\n            const isValidMessage = this.isValidMessage(ev);\n\n            const message = deserialize(ev.data);\n\n            if (isValidMessage) {\n                switch (message.type) {\n                    case MessageType.EVENT: {\n                        this.handleEvent(message);\n                        break;\n                    }\n                    case MessageType.REQUEST: {\n                        this.handleRequest(message);\n                        break;\n                    }\n                    case MessageType.ERROR_RESPONSE:\n                    case MessageType.RESPONSE: {\n                        this.handleResponse(message);\n                        break;\n                    }\n                }\n\n                this.profiler.logEvent(\n                    ProfileEventType.RECEIVE_MESSAGE,\n                    message\n                );\n            } else {\n                this.logger.error('Invalid message format. Skipping.');\n            }\n        } catch (e) {\n            // if handshake fails, do nothing\n        }\n    }\n\n    protected handleEvent<T = any>(message: Message<T>) {\n        const subscriptions = this.eventSubscriptions[message.key];\n\n        if (subscriptions) {\n            Object.values(subscriptions).forEach(handler =>\n                handler(message.data, message)\n            );\n        }\n    }\n\n    protected handleRequest<Q = any>(message: Message<Q>) {\n        const handler = this.requestSubscriptions[message.key];\n\n        if (handler) {\n            handler(message.data, message);\n\n            this.logger.log(`Handled request type ${message.key}`);\n        }\n    }\n\n    protected handleResponse<R = any>(message: Message<R>) {\n        const requestId = message.requestId;\n\n        const handler = requestId && this.responseSubscriptions[requestId];\n\n        if (handler) {\n            handler(message.data, message);\n        }\n    }\n\n    protected async postMessage<T = any>(\n        type: MessageType,\n        key: string,\n        data: T,\n        requestId?: string\n    ): Promise<Message<T>> {\n        const { port } = await this.getChannel();\n\n        if (this.destroyed) {\n            throw new ClientDestroyedError();\n        }\n\n        const message: Message = serialize({\n            type,\n            apiVersion: MessageAPIVersion.v1,\n            key,\n            data,\n            id: randomInsecureId(),\n            requestId\n        });\n\n        port.postMessage(message);\n\n        this.profiler.logEvent(ProfileEventType.POST_MESSAGE, message);\n\n        return message;\n    }\n\n    protected setInitTimer() {\n        this.initTimer = setTimeout(() => {\n            this.channel.reject(new HandshakeTimeoutError());\n            this.destroy();\n        }, this.handshakeTimeout);\n    }\n\n    protected initListener(ev: MessageEvent<Message<C>>) {\n        if (this.isInitMessage(ev)) {\n            this.profiler.logEvent(ProfileEventType.RECEIVE_MESSAGE, ev.data);\n\n            if (this.initTimer) {\n                clearTimeout(this.initTimer);\n            }\n\n            this.onChannelInit(ev);\n\n            if (this.messagePort) {\n                this.messagePort.onmessage = this.messageListener.bind(this);\n            }\n\n            this.resolveChannel(ev);\n        } else {\n            this.logger.error('Invalid message format. Skipping.');\n        }\n    }\n\n    protected isValidMessage(ev: MessageEvent<any>): boolean {\n        const message = ev.data;\n\n        return (\n            message.type &&\n            message.id &&\n            message.apiVersion === MessageAPIVersion.v1\n        );\n    }\n\n    protected isInitMessage(ev: MessageEvent<any>): boolean {\n        return (\n            this.isValidMessage(ev) && ev.data.type === MessageType.CHANNEL_INIT\n        );\n    }\n\n    protected resolveChannel(ev: MessageEvent<Message<C>>) {\n        if (this.messagePort) {\n            const channel: Channel<C> = {\n                port: this.messagePort,\n                origin: ev.origin,\n                context: ev.data.data\n            };\n\n            this.channel.resolve(channel);\n        }\n    }\n\n    protected getInitMessage<T = any>(context: T): Message<T> {\n        const message: Message<T> = serialize({\n            type: MessageType.CHANNEL_INIT,\n            apiVersion: MessageAPIVersion.v1,\n            key: '',\n            data: context,\n            id: randomInsecureId()\n        });\n\n        return message;\n    }\n\n    destroy() {\n        this.destroyed = true;\n        this.channel.reject(new ClientDestroyedError());\n\n        if (this.messagePort) {\n            this.messagePort.close();\n        }\n\n        if (this.initTimer) {\n            clearTimeout(this.initTimer);\n        }\n\n        Object.values(this.onDestroyRequestHandlers).forEach(destroy =>\n            destroy()\n        );\n    }\n}\n","import {\n    ProfileEventType,\n    TransactionDirection,\n    REQUEST_KEY_GET_PROFILE,\n    SerializationType\n} from './constants';\nimport { HandshakeTimeoutError, RequestTimeoutError } from './errors';\nimport type {\n    Deferred,\n    Message,\n    MessageProfileEvent,\n    MessageProfile,\n    SerializedError\n} from './types';\n\nexport const defer = <T>(): Deferred<T> => {\n    let resolve: (t: T) => void = () => {};\n    let reject: (e?: any) => void = () => {};\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n\n    return {\n        resolve,\n        reject,\n        promise\n    };\n};\n\n/* eslint-disable no-bitwise */\nexport const randomInsecureId = (len: number = 16): string =>\n    [...Array(len)].map(() => (~~(Math.random() * 36)).toString(36)).join('');\n/* eslint-enable */\n\nexport const omit = (object: any, key: string): any => {\n    const { [key]: _, ...rest } = object;\n\n    return rest;\n};\n\nconst keyBy = <T>(\n    items: T[],\n    getId: (item: T) => string\n): { [key: string]: T } => {\n    const out: { [key: string]: T } = {};\n\n    items.forEach(item => {\n        out[getId(item)] = item;\n    });\n\n    return out;\n};\n\nexport const profileMessages = (\n    parentEvents: MessageProfileEvent[],\n    childEvents: MessageProfileEvent[]\n): MessageProfile[] => {\n    const allEvents = parentEvents.concat(childEvents);\n    const receiveEvents = allEvents.filter(\n        item => item.type === ProfileEventType.RECEIVE_MESSAGE\n    );\n    const receiveEventsByMessageID = keyBy(\n        receiveEvents,\n        item => item.message.id\n    );\n\n    const transactions: MessageProfile[] = [];\n\n    const getBaseTransaction = ({\n        date,\n        message\n    }: MessageProfileEvent): MessageProfile => {\n        const transaction: MessageProfile = {\n            id: message.id,\n            direction: TransactionDirection.DOWN,\n            postTime: date,\n            message\n        };\n\n        const receiveEvent = receiveEventsByMessageID[message.id];\n\n        if (receiveEvent) {\n            transaction.receiveTime = receiveEvent.date;\n            transaction.duration =\n                (receiveEvent.date.getTime() - date.getTime()) / 1000;\n        }\n\n        return transaction;\n    };\n\n    parentEvents\n        .filter(item => item.type === ProfileEventType.POST_MESSAGE)\n        .forEach(ev => {\n            const transaction = getBaseTransaction(ev);\n\n            transactions.push(transaction);\n        });\n\n    childEvents\n        .filter(item => item.type === ProfileEventType.POST_MESSAGE)\n        .forEach(ev => {\n            const transaction = getBaseTransaction(ev);\n\n            transaction.direction = TransactionDirection.UP;\n\n            transactions.push(transaction);\n        });\n\n    return transactions\n        .filter(item => item.message.key !== REQUEST_KEY_GET_PROFILE)\n        .sort((a, b) => a.postTime.getTime() - b.postTime.getTime());\n};\n\nconst serializeError = (error: Error): SerializedError => {\n    return {\n        message: error.message,\n        name: error.name,\n        stack: error.stack\n    };\n};\n\nconst deserializeError = ({ name, message, stack }: SerializedError): Error => {\n    switch (name) {\n        case HandshakeTimeoutError.name: {\n            return new HandshakeTimeoutError();\n        }\n        case RequestTimeoutError.name: {\n            return new RequestTimeoutError();\n        }\n        default: {\n            const e = new Error(message);\n            e.name = name;\n            e.stack = stack;\n            return e;\n        }\n    }\n};\n\nexport const serialize = (message: Omit<Message, 'serialization'>): Message => {\n    let data = message.data;\n    let serialization = SerializationType.NONE;\n\n    if (data instanceof Error) {\n        serialization = SerializationType.ERROR;\n        data = serializeError(data);\n    }\n\n    return {\n        ...message,\n        serialization,\n        data\n    };\n};\n\nexport const deserialize = (message: Message): Message => {\n    if (message.serialization === SerializationType.ERROR) {\n        return {\n            ...message,\n            data: deserializeError(message.data)\n        };\n    }\n\n    return message;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(920);\n"],"names":["root","factory","exports","module","define","amd","self","options","context","initListener","bind","window","addEventListener","profile","onRequest","REQUEST_KEY_GET_PROFILE","profiler","getEvents","setInitTimer","getLogger","this","debug","onChannelInit","ev","removeEventListener","messagePort","ports","message","getInitMessage","postMessage","logEvent","ProfileEventType","POST_MESSAGE","destroy","SharedClient","ChildClient","SerializationType","TransactionDirection","MessageType","MessageAPIVersion","DEFAULT_REQUEST_TIMEOUT","Object","setPrototypeOf","HandshakeTimeoutError","prototype","name","Error","RequestTimeoutError","ClientDestroyedError","ParentClient","prefix","log","console","error","requestChannel","frame","contentWindow","handleRequstChannel","src","requestChannelWithPopup","targetWindow","url","opener","URL","messageChannel","MessageChannel","port1","onmessage","origin","port2","getMessageProfile","request","childEvents","events","profileMessages","getProfiler","type","push","date","Date","handshakeTimeout","requestTimeout","undefined","channel","defer","eventSubscriptions","responseSubscriptions","requestSubscriptions","onDestroyRequestHandlers","destroyed","logger","getChannel","then","catch","reason","send","eventType","data","handshake","EVENT","on","handler","id","randomInsecureId","omit","requestKey","REQUEST","sentMessage","requestId","unsubscribeResponseHandler","clearOnDestroy","Promise","resolve","reject","timer","response","clearTimeout","ERROR_RESPONSE","setTimeout","timeout","requestHandler","requestData","requestMessage","RESPONSE","getContext","promise","messageListener","isValidMessage","deserialize","handleEvent","handleRequest","handleResponse","RECEIVE_MESSAGE","subscriptions","key","values","forEach","port","serialize","apiVersion","v1","initTimer","isInitMessage","resolveChannel","CHANNEL_INIT","close","res","rej","len","Array","map","Math","random","toString","join","object","parentEvents","getId","out","receiveEvents","concat","filter","item","receiveEventsByMessageID","transactions","getBaseTransaction","transaction","direction","DOWN","postTime","receiveEvent","receiveTime","duration","getTime","UP","sort","a","b","deserializeError","stack","e","serialization","NONE","ERROR","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}