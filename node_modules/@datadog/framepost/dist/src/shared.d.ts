import { MessageType } from './constants';
import { Logger } from './logger';
import { Profiler } from './profiler';
import type { Deferred, Message, Channel, EventHandler, RequestHandler, RequestOptions } from './types';
export interface SharedClientOptions {
    debug?: boolean;
    profile?: boolean;
    handshakeTimeout?: number;
    requestTimeout?: number;
}
export declare abstract class SharedClient<C> {
    protected readonly debug: boolean;
    protected readonly profile: boolean;
    protected destroyed: boolean;
    protected readonly handshakeTimeout: number;
    protected readonly requestTimeout: number;
    protected readonly channel: Deferred<Channel<C>>;
    protected readonly logger: Logger;
    protected readonly profiler: Profiler;
    protected messagePort?: MessagePort;
    protected initTimer?: ReturnType<typeof setTimeout>;
    protected eventSubscriptions: {
        [eventType: string]: {
            [id: string]: EventHandler;
        };
    };
    protected responseSubscriptions: {
        [id: string]: EventHandler;
    };
    protected requestSubscriptions: {
        [requestKey: string]: RequestHandler;
    };
    protected onDestroyRequestHandlers: {
        [id: string]: () => void;
    };
    constructor({ debug, profile, handshakeTimeout, requestTimeout }?: SharedClientOptions);
    protected abstract onChannelInit(event: MessageEvent<Message<C>>): void;
    protected abstract getLogger(): Logger;
    /**
     * Sends an event to the opposite client
     */
    send<T = any>(eventType: string, data: T): Promise<Message<T> | null>;
    /**
     * Subscribes an event handler for the given eventType. Returns an unsubscribe hook
     */
    on<T = any>(eventType: string, handler: EventHandler<T>): () => void;
    /**
     * Sends a request to the opposite client. There must be an accompanying request handler
     * subscribed with `onRequest`. Resolves with the returned data or times out.
     */
    request<Q = any, R = any>(requestKey: string, data?: Q, options?: RequestOptions): Promise<R>;
    /**
     * Subscribes a request handler for the given request key. The return value
     * from the subscribed handler is sent back to the opposite client. The handler may be async.
     * Unlike event handlers, there may be only one request handler per request key. Returns
     * an unsubscribe hook.
     */
    onRequest<Q = any, R = any>(requestKey: string, requestHandler: RequestHandler<Q, R>): () => void;
    /**
     * Returns the context provided by the opposite client, or null
     * if the handshake process fails
     */
    getContext(): Promise<C | null>;
    /**
     * Rejects if the handshake process has failed or if the client was destroyed
     */
    handshake(): Promise<C>;
    /**
     * A wrapper around the channel deferred object that also checks
     * if the client has been destroyed before returning
     */
    protected getChannel(): Promise<Channel<C>>;
    protected messageListener(ev: MessageEvent<Message>): Promise<void>;
    protected handleEvent<T = any>(message: Message<T>): void;
    protected handleRequest<Q = any>(message: Message<Q>): void;
    protected handleResponse<R = any>(message: Message<R>): void;
    protected postMessage<T = any>(type: MessageType, key: string, data: T, requestId?: string): Promise<Message<T>>;
    protected setInitTimer(): void;
    protected initListener(ev: MessageEvent<Message<C>>): void;
    protected isValidMessage(ev: MessageEvent<any>): boolean;
    protected isInitMessage(ev: MessageEvent<any>): boolean;
    protected resolveChannel(ev: MessageEvent<Message<C>>): void;
    protected getInitMessage<T = any>(context: T): Message<T>;
    destroy(): void;
}
